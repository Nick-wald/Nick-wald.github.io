<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NickBlog</title>
  
  
  <link href="/Nick-wald.github.io/atom.xml" rel="self"/>
  
  <link href="https://nickwald.top/"/>
  <updated>2020-05-30T01:24:24.635Z</updated>
  <id>https://nickwald.top/</id>
  
  <author>
    <name>NickWald&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>矩阵取数游戏</title>
    <link href="https://nickwald.top/2020/05/29/P1005%E9%A2%98%E8%A7%A3/"/>
    <id>https://nickwald.top/2020/05/29/P1005%E9%A2%98%E8%A7%A3/</id>
    <published>2020-05-29T14:53:47.931Z</published>
    <updated>2020-05-30T01:24:24.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的<script type="math/tex">n \times m</script>的矩阵，矩阵中的每个元素<script type="math/tex">a_{i,j}</script>均为非负整数。游戏规则如下：</p><ul><li>每次取数时须从每行各取走一个元素，共<script type="math/tex">n</script>个。经过<script type="math/tex">m</script>次后取完矩阵内所有元素；</li><li>每次取走的各个元素只能是该元素所在行的行首或行尾；</li><li>每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值<script type="math/tex">\times 2^i</script>，其中<script type="math/tex">i</script>表示第<script type="math/tex">i</script>次取数（从<script type="math/tex">1</script>开始编号）；</li><li>游戏结束总得分为<script type="math/tex">m</script>次取数得分之和。<br>帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。<a id="more"></a><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2>输入文件包括<script type="math/tex">n+1</script>行：<br>第一行为两个用空格隔开的整数<script type="math/tex">n</script>和<script type="math/tex">m</script>。<br>第<script type="math/tex">2 \backsim n+1</script>行为<script type="math/tex">n \times m</script>矩阵，其中每行有<script type="math/tex">m</script>个用单个空格隔开的非负整数。<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2>输出文件仅包含<script type="math/tex">1</script>行，为一个整数，即输入矩阵取数后的最大得分。<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2>输入#1<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>输出#1<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">82</span></span><br></pre></td></tr></table></figure><h2 id="说明-amp-提示"><a href="#说明-amp-提示" class="headerlink" title="说明&amp;提示"></a>说明&amp;提示</h2>NOIP 2007 提高第三题。<br>数据范围：<br><script type="math/tex">60\%</script>的数据满足：<script type="math/tex">1\le n,m\le 30</script>，答案不超过<script type="math/tex">10^{16}</script>。<br><script type="math/tex">100\%</script>的数据满足：<script type="math/tex">1\le n,m\le 80</script>，<script type="math/tex">0\le a_{i,j}\le1000</script>。<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1>先分析题目，题目大意可以概括为：<div class="note default"><p>有一个<script type="math/tex">n \times m</script>的矩阵，对于第<script type="math/tex">i</script>行，每次取走边缘的值<script type="math/tex">A_{i,j}</script>，增加这一行的得分（自行看题目规则），求<script type="math/tex">n</script>行的最大得分总和。</p></div>好了直接贴代码（已AC）：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">85</span>, Mod = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> num[MAX];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIGN</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">505</span>], len;</span><br><span class="line">    BIGN()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="comment">//构造函数：创建高精度变量 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, p[len]);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;  </span><br><span class="line">            <span class="keyword">if</span> (p[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"0000"</span>); </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">10</span>; k * p[i] &lt; Mod; k *= <span class="number">10</span>) </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//输出（高精度四位压缩 </span></span><br><span class="line">&#125; f[MAX][MAX], tbase[MAX], answer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重载运算符 </span></span><br><span class="line">BIGN <span class="keyword">operator</span> + (<span class="keyword">const</span> BIGN &amp;a, <span class="keyword">const</span> BIGN &amp;b) &#123;</span><br><span class="line">    BIGN c; c.len = <span class="built_in">max</span>(a.len, b.len); <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c.len; i++) &#123;</span><br><span class="line">        c.p[i] = a.p[i] + b.p[i] + x;</span><br><span class="line">        x = c.p[i] / Mod;</span><br><span class="line">        c.p[i] %= Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">        c.p[++c.len] = x;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125; <span class="comment">//+</span></span><br><span class="line"></span><br><span class="line">BIGN <span class="keyword">operator</span> * (<span class="keyword">const</span> BIGN &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)&#123;</span><br><span class="line">    BIGN c; c.len = a.len; <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c.len; i++) &#123;</span><br><span class="line">        c.p[i] = a.p[i] * b + x;</span><br><span class="line">        x = c.p[i] / Mod;</span><br><span class="line">        c.p[i] %= Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">        c.p[++c.len] = x % Mod, x /= Mod;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125; <span class="comment">//*</span></span><br><span class="line"></span><br><span class="line"><span class="function">BIGN <span class="title">max</span><span class="params">(<span class="keyword">const</span> BIGN &amp;a, <span class="keyword">const</span> BIGN &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.len &gt; b.len)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.len &lt; b.len)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.len; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (a.p[i] &gt; b.p[i])</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a.p[i] &lt; b.p[i])</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123;<span class="comment">//2幂预处理 </span></span><br><span class="line">    tbase[<span class="number">0</span>].p[<span class="number">1</span>] = <span class="number">1</span>, tbase[<span class="number">0</span>].len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">2</span>; i++)&#123;</span><br><span class="line">        tbase[i] = tbase[i - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    two();</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= i; j--)&#123;<span class="comment">//DP大》小 </span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j] + tbase[m - j + i - <span class="number">1</span>] * num[i - <span class="number">1</span>]); </span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j + <span class="number">1</span>] + tbase[m - j + i - <span class="number">1</span>] * num[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        BIGN Max;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            Max = <span class="built_in">max</span>(Max, f[i][i] + tbase[m] * num[i]);</span><br><span class="line">        answer = answer + Max; </span><br><span class="line">    &#125;</span><br><span class="line">    answer.<span class="built_in">print</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的&lt;script type=&quot;math/tex&quot;&gt;n \times m&lt;/script&gt;的矩阵，矩阵中的每个元素&lt;script type=&quot;math/tex&quot;&gt;a_{i,j}&lt;/script&gt;均为非负整数。游戏规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次取数时须从每行各取走一个元素，共&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;个。经过&lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;次后取完矩阵内所有元素；&lt;/li&gt;
&lt;li&gt;每次取走的各个元素只能是该元素所在行的行首或行尾；&lt;/li&gt;
&lt;li&gt;每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值&lt;script type=&quot;math/tex&quot;&gt;\times 2^i&lt;/script&gt;，其中&lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;表示第&lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;次取数（从&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;开始编号）；&lt;/li&gt;
&lt;li&gt;游戏结束总得分为&lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;次取数得分之和。&lt;br&gt;帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://nickwald.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="提高/省选" scheme="https://nickwald.top/categories/%E9%A2%98%E8%A7%A3/%E6%8F%90%E9%AB%98-%E7%9C%81%E9%80%89/"/>
    
    
      <category term="C" scheme="https://nickwald.top/tags/C/"/>
    
      <category term="提高/省选" scheme="https://nickwald.top/tags/%E6%8F%90%E9%AB%98-%E7%9C%81%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>MathJax使用手册</title>
    <link href="https://nickwald.top/2020/05/24/MathJax%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <id>https://nickwald.top/2020/05/24/MathJax%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</id>
    <published>2020-05-24T04:08:24.837Z</published>
    <updated>2020-05-30T00:56:06.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MathJax简介"><a href="#MathJax简介" class="headerlink" title="MathJax简介"></a>MathJax简介</h1><p>MathJax是一款运行在浏览器中的开源数学符号渲染引擎，使用MathJax可以方便的在浏览器中显示数学公式，不需要使用图片。目前，MathJax可以解析Latex、MathML和ASCIIMathML的标记语言。MathJax项目于2009年开始，发起人有American Mathematical Society, Design Science等，还有众多的支持者，个人感觉MathJax会成为今后数学符号渲染引擎中的主流，也许现在已经是了。本文接下来会讲述MathJax的基础用法，但不涉及MathJax的安装及配置。此外，推荐使用StackEdit学习MathJax的语法，它支持Markdown和MathJax。<br><a id="more"></a></p><h1 id="MathJax语法"><a href="#MathJax语法" class="headerlink" title="MathJax语法"></a>MathJax语法</h1><h2 id="公式标记-amp-查看公式"><a href="#公式标记-amp-查看公式" class="headerlink" title="公式标记&amp;查看公式"></a>公式标记&amp;查看公式</h2><p>使用MathJax时，需要用一些适当的标记告诉MathJax某段文本是公式代码。此外，MathJax中的公式排版有两种方式，inline和displayed。inline表示公式嵌入到文本段中，displayed表示公式独自成为一个段落。例如，$f(x) = 3 \times x$这是一个inline公式，而下面</p><script type="math/tex; mode=display">f(x) = 3 \times x</script><p>则是一个displayed公式。<br>下文中，使用<code>￥￥...￥￥</code>（￥替换为美元符号）作为displayed分隔符，<code>￥...￥</code>作为inline分隔符。此外，可以在渲染完成的公式上方右键点击，唤出右键菜单。在菜单中提供了查看公式代码、设置显示效果和渲染模式的选项。</p><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><p>使用MathJax可以非常方便的输入各种希腊字母，具体如下表：</p><div class="table-container"><table><thead><tr><th>名称</th><th>大写</th><th>Tex</th><th>小写</th><th>Tex</th></tr></thead><tbody><tr><td>alpha</td><td>$A$</td><td>A</td><td>$\alpha$</td><td>\alpha</td></tr><tr><td>beta</td><td>$B$</td><td>B</td><td>$\beta$</td><td>\beta</td></tr><tr><td>gamma</td><td>$\Gamma$</td><td>\Gamma</td><td>$\gamma$</td><td>\gamma</td></tr><tr><td>delta</td><td>$\Delta$</td><td>\Delta</td><td>$\delta$</td><td>\delta</td></tr><tr><td>epsilon</td><td>$E$</td><td>E</td><td>$\epsilon$</td><td>\epsilon</td></tr><tr><td>zeta</td><td>$Z$</td><td>Z</td><td>$\zeta$</td><td>\zeta</td></tr><tr><td>eta</td><td>$H$</td><td>H</td><td>$\eta$</td><td>\eta</td></tr><tr><td>theta</td><td>$\Theta$</td><td>\Theta</td><td>$\theta$</td><td>\theta</td></tr><tr><td>iota</td><td>$I$</td><td>I</td><td>$\iota$</td><td>\iota</td></tr><tr><td>kappa</td><td>$K$</td><td>K</td><td>$\kappa$</td><td>\kappa</td></tr><tr><td>lambda</td><td>$\Lambda$</td><td>\Lambda</td><td>$\lambda$</td><td>\lambda</td></tr><tr><td>mu</td><td>$M$</td><td>M</td><td>$\mu$</td><td>\mu</td></tr><tr><td>nu</td><td>$N$</td><td>N</td><td>$\nu$</td><td>\nu</td></tr><tr><td>xi</td><td>$\Xi$</td><td>\Xi</td><td>$\xi$</td><td>\xi</td></tr><tr><td>omicron</td><td>$O$</td><td>O</td><td>$\omicron$</td><td>\omicron</td></tr><tr><td>pi</td><td>$\Pi$</td><td>\Pi</td><td>$\pi$</td><td>\pi</td></tr><tr><td>rho</td><td>$P$</td><td>P</td><td>$\rho$</td><td>\rho</td></tr><tr><td>sigma</td><td>$\Sigma$</td><td>\Sigma</td><td>$\sigma$</td><td>\sigma</td></tr><tr><td>tau</td><td>$T$</td><td>T</td><td>$\tau$</td><td>\tau</td></tr><tr><td>upsilon</td><td>$\Upsilon$</td><td>\Upsilon</td><td>$\upsilon$</td><td>\upsilon</td></tr><tr><td>phi</td><td>$\Phi$</td><td>\Phi</td><td>$\phi$</td><td>\phi</td></tr><tr><td>chi</td><td>$X$</td><td>X</td><td>$\chi$</td><td>\chi</td></tr><tr><td>psi</td><td>$\Psi$</td><td>\Psi</td><td>$\psi$</td><td>\psi</td></tr><tr><td>omega</td><td>$\Omega$</td><td>\Omega</td><td>$\omega$</td><td>\omega</td></tr></tbody></table></div><h2 id="上标-amp-下标"><a href="#上标-amp-下标" class="headerlink" title="上标&amp;下标"></a>上标&amp;下标</h2><p>上标和下标分别使用^与_（详细右键点击公式，选择”Show Math As-Tex Commands”，下同）</p><script type="math/tex; mode=display">x^2\tag{1.1}</script><script type="math/tex; mode=display">x_i\tag{1.2}</script><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><ol><li>小括号与方括号：使用原始的()，[]即可：$(2+3)[4+4]$</li><li>大括号：由于大括号<code>{}</code>被用来分组，因此需要使用<code>\{</code>和<code>\}</code>表示大括号，也可以使用<code>\lbrace</code>和<code>\rbrace</code>来表示。</li><li>尖括号：使用<code>\langle</code>和<code>\rangle</code>表示左尖括号和右尖括号。</li><li>上取整：使用<code>\lceil</code>和<code>\rceil</code>表示。</li><li>下取整：使用<code>\lfloor</code>和<code>\rfloor</code>表示。</li><li>不可见括号：使用.表示。<br>需要注意的是，原始符号并不会随着公式大小缩放，可以使用<code>\left(...\right)</code>来自适应地调整括号大小。如下，<script type="math/tex; mode=display">\lbrace\sum_{i=0}^0 i^2 = \frac{(n^2+n)(2n+2)}{6}\rbrace\tag{2.1}</script><script type="math/tex; mode=display">\left\lbrace\sum_{i=0}^0 i^2 = \frac{(n^2+n)(2n+2)}{6}\right\rbrace\tag{2.2}</script><h2 id="求和-amp-积分"><a href="#求和-amp-积分" class="headerlink" title="求和&amp;积分"></a>求和&amp;积分</h2></li><li><code>\sum</code>用来表示求和符号，其下标表示求和下限，上标表示上限：<script type="math/tex">\sum_1^n</script></li><li><code>\int</code>用来表示积分符号，同样地，其上下标表示积分的上下限。<script type="math/tex">\int_1^\infty</script></li><li>与此类似的符号还有：<code>\prod</code>$\prod$，<code>\bigcup</code>$\bigcup$, <code>\bigcap</code>$\bigcap$，<code>\iint</code>$\iint$。<h2 id="分式-amp-根式"><a href="#分式-amp-根式" class="headerlink" title="分式&amp;根式"></a>分式&amp;根式</h2></li><li>使用<code>\frac ab</code> , <code>\frac</code>作用于其后的两个组a , b ，结果为$\frac ab$，如果你的分子或分母不是单个字符，请使用<code>{...}</code>来分组。</li><li>使用<code>{...\over...}</code>来分隔一个组的前后两部分，如${a+1 \over b+1}$<br>根式使用<code>\sqrt[x]{...}</code>表示，如$\sqrt[4]{\frac xy}$<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2></li><li>使用<code>\mathbb{...}</code>或<code>\Bbb{...}</code>显示黑板粗体字，此字体经常用来表示实数、整数、有理数、复数。如$\mathbb{CHNQRZ}$</li><li>使用<code>\mathbf</code>显示黑体字（格式同上）</li><li>使用<code>\mathtt</code>显示打印机字体</li><li>使用<code>\mathrm</code>显示罗马字体</li><li>使用<code>\mathscr</code>显示手写体</li><li>使用<code>\mathfrak</code>显示Fraktur字母（一种德国字体）<h2 id="特殊函数-amp-符号"><a href="#特殊函数-amp-符号" class="headerlink" title="特殊函数&amp;符号"></a>特殊函数&amp;符号</h2></li><li>三角：<code>\sin x</code>，<code>\arctan_x</code>，<code>\lim_{1\to\infty}</code></li><li>比较运算符：<code>\lt</code> <code>\gt</code> <code>\le</code> <code>\ge</code> <code>\neq</code></li><li><code>\times</code>乘 <code>\div</code>除 <code>\pm</code>正负号 <code>\mp</code>负正号，<code>\cdot</code>表示居中的点</li><li>集合关系与运算：<code>\cup</code> <code>\cap</code> <code>\setminus</code> <code>\subset</code> <code>\subseteq</code> <code>\subsetneq</code> <code>\supset</code> <code>\in</code> <code>\notin</code> <code>\emptyset</code> <code>\varnothing</code></li><li>表示排列使用<code>\binom{n+1}{2k}</code>或<code>{n+1 \choose 2k}</code></li><li>箭头：<code>\to</code> <code>\rightarrow</code> <code>\leftarrow</code> <code>\Rightarrow</code> <code>\Leftarrow</code> <code>\mapsto</code></li><li>逻辑运算符：<code>\land</code> <code>\lor</code> <code>\lnot</code> <code>\forall</code> <code>\exists</code> <code>\top</code> <code>\bot</code> <code>\vdash</code> <code>\vDash</code></li><li><code>\star</code> <code>\ast</code> <code>\oplus</code> <code>\circ</code> <code>\bullet</code></li><li><code>\approx</code> <code>\sim</code> <code>\cong</code> <code>\equiv</code> <code>\prec</code></li><li><code>\infty</code> <code>\aleph_o</code> <code>\nabla</code> <code>\partial</code> <code>\Im</code> <code>\Re</code></li><li>模运算 <code>\pmode</code></li><li><code>\ldots</code>与<code>\cdots</code>，其区别是dots的位置不同，ldots位置稍低，cdots位置居中<script type="math/tex; mode=display">a_1 + a_2 + \cdots + a_n , a_1, a_2, \ldots , a_n\tag{3.1}</script></li><li>一些希腊字母具有变体形式，如<code>\epsilon</code> <code>\varepsilon</code>，<code>\phi</code> <code>\varphi</code><h2 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h2>通常MathJax通过内部策略自己管理公式内部的空间，因此<code>a...b</code>与<code>a......b</code>(<code>.</code> 表示空格)都会显示为ab。可以通过在ab间加入<code>\,</code>增加些许间隙，<code>\;</code>增加较宽间隙，<code>\quad</code>与<code>\qquad</code>会增加更大的间隙<h2 id="顶部符号"><a href="#顶部符号" class="headerlink" title="顶部符号"></a>顶部符号</h2>对于单字符，<code>\hat</code> $\hat x$<br>对于多字符，<code>\widehat</code> $\widehat {xy}$<br>类似的还有 <code>\overline</code> , <code>\vec</code> , <code>\overrightarrow</code> , <code>\dot</code> , <code>\ddot</code><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2>使用<code>\begin{array}{列样式}...\end{array}</code>这样的形式来创建表格，列样式可以是clr表示居中，左，右对齐，还可以使用<code>|</code>表示一条竖线。表格中各行使用<code>\\</code>分隔，各列使用<code>&amp;</code>分隔，使用<code>\hline</code>在本行前加入一条直线。例如：<script type="math/tex; mode=display">\begin{array}{c|lcr} n & \text{Left} & \text{Center} & \text{Right} \\ \hline 1 & 0.24 & 1 & 125 \\ 2 & -1 & 189 & -8 \\ 3 & -20 & 2000 & 1+10i \\ \end{array}\tag{4.1}</script><script type="math/tex; mode=display">\begin{array}{c}\begin{array}{cc}\begin{array}{c|cccc} \text{min} & 0 & 1 & 2 &3 \\ \hline 0 & 0 & 0 & 0 & 0 \\ 1 & 0 & 1 & 1 & 1 \\ 2 & 0 & 1 & 2 & 2 \\ 3 & 0 & 1 & 2 & 3  \end{array} & \begin{array}{c|cccc} \text{max} & 0 & 1 & 2 & 3 \\ \hline 0 & 0 & 1 & 2 & 3 \\ 1 & 1 & 1 & 2 & 3 \\ 2 & 2 & 2 & 2 & 3 \\ 3 & 3 & 3 & 3 & 3 \end{array} \end{array} \\ \begin{array}{c|cccc} \Delta & 0 & 1 & 2 & 3 \\ \hline 0 & 0 & 1 & 2 & 3 \\ 1 & 1 & 0 & 1 & 2 \\ 2 & 2 & 1 & 0 & 1 \\ 3 & 3 & 2 & 1 & 0 \end{array}\end{array}\tag{4.2}</script><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2>使用<code>\begin{matrix}...\end{matrix}</code>来表示矩阵，在<code>\begin</code>与<code>\end</code>之间加入矩阵的元素即可。矩阵的行之间用<code>\\</code>分隔，列之间用<code>&amp;</code>分隔。例如：<script type="math/tex; mode=display">\begin{matrix} 1 & x & x^2 \\ 1 & y & y^2 \\ 1 & z & z^2 \end{matrix}\tag{5.1}</script>如果要对矩阵加括号，可以像上文中提到的那样，使用<code>\left</code>与<code>\right</code>配合表示括号符号。也可以使用特殊的matrix，即替换<code>\begin{matrix}...\end{matrix}</code>中的matrix为pmatrix , bmatrix , Bmatrix , vmatrix , Vmatrix。例如：<script type="math/tex; mode=display">\begin{pmatrix} 1 & 2 \\ 3 & 4 \\ \end{pmatrix} \begin{bmatrix} 1 & 2 \\ 3 & 4 \\ \end{bmatrix} \begin{Bmatrix} 1 & 2 \\ 3 & 4 \\ \end{Bmatrix} \begin{vmatrix} 1 & 2 \\  3 & 4 \\ \end{vmatrix} \begin{Vmatrix} 1 & 2 \\ 3 & 4 \\ \end{Vmatrix}\tag{5.2}</script>也可以使用<code>\cdots</code> <code>\ddots</code> <code>\vdots</code>来省略矩阵中的元素：<script type="math/tex; mode=display">\begin{pmatrix} 1 & a_1 & a_1^2 & \cdots & a_1^n \\ 1 & a_2 & a_2^2 & \cdots & a_2^n \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ 1 & a_m & a_m^2 & \cdots & a_m^n \end{pmatrix}\tag{5.3}</script>增广矩阵需要使用前面的array来实现，如下：<script type="math/tex; mode=display">\left[ \begin{array}{cc|c} 1 & 2 & 3 \\ 4 & 5 & 6 \end{array} \right]\tag{5.4}</script><h2 id="公式对齐"><a href="#公式对齐" class="headerlink" title="公式对齐"></a>公式对齐</h2>有时候可能需要一系列的公式中等号对齐，这时候需要使用形如<code>\begin{align}...\end{align}</code>的格式，其中需要使用<code>&amp;</code>来指示需要对齐的位置，如：<script type="math/tex; mode=display">\begin{align} \sqrt{37} & = \sqrt{\frac{73^2-1}{12^2}} \\ & = \sqrt{\frac{73^2}{12^2} \cdot \frac{73^2-1}{73^2}} \\ & = \frac{73}{12} \sqrt{1 - \frac{1}{73^2}} \\ & \approx \frac{73}{12} \left( 1 - \frac{1}{2 \cdot 73^2} \right) \end{align}</script><h2 id="分类表达式"><a href="#分类表达式" class="headerlink" title="分类表达式"></a>分类表达式</h2>定义函数的时候经常需要分情况给出表达式，可使用<code>\begin{cases}...\end{cases}</code>。其中，使用<code>\</code>来分类，使用&amp;指示需要对齐的位置。如：<script type="math/tex; mode=display">f(n) = \begin{cases} n/2, & \text{if $n$ is even} \\ 3n+1, & \text{if $n$ is odd} \end{cases}</script>上述公式也可以移动到右侧，不过需要使用array来实现，如下：<script type="math/tex; mode=display">\left. \begin{array}{l} \text{if $n$ is even:} & n/2 \\ \text{if $n$ is odd:} & 3n+1 \end{array} \right\} = f(n)</script>如果需要让分类之间的垂直间隔变大，可以使用<code>\[2ex]</code>代替<code>\</code>来分隔不同情况。（3ex, 4ex也可以使用，1ex相当于原始距离）。<h2 id="公式标记-amp-引用"><a href="#公式标记-amp-引用" class="headerlink" title="公式标记&amp;引用"></a>公式标记&amp;引用</h2>使用<code>\tag{yourtat}</code>来标记公式，如果想在之后引用该公式，则还需要加上<code>\label{yourlabel}</code>在<code>\tag</code>之后，如：<script type="math/tex; mode=display">:= x^2-y^3 \tag{*}\label{*}</script>为了引用公式，可以使用<code>\eqref{rlabel}</code>，如：<script type="math/tex; mode=display">a+y^3 \stackrel{\eqref{*}}=x^2</script>可以看到，通过超链接可以跳转到被引用公式的位置。<h2 id="更多关于空间的问题……"><a href="#更多关于空间的问题……" class="headerlink" title="更多关于空间的问题……"></a>更多关于空间的问题……</h2>在使用LaTex公式时，有一些不会影响公式正确性，但会使其看上去很糟糕的问题……</li></ol><ul><li>不要在指数或者积分中使用<code>\frac</code><br>在指数或者基本表达式中使用<code>\frac</code>会使表达式看起来不清晰，因此在专业的数学排版中很少被使用。应该使用一个水平的<code>/</code>来代替，效果如下：<script type="math/tex; mode=display">\begin{array}{cc} \mathrm{Bad} & \mathrm{Better} \\ \hline \\ e^{i\frac{\pi}{2}} \quad e^{\frac{i\pi}{2}} & e^{i\pi/2} \\ \int_{-\frac{\pi}{2}}^{\frac{\pi}{2}} \sin x \, dx & \int_{-\pi/2}^{\pi/2} \sin x \, dx \\ \end{array}</script></li><li>使用<code>\mid</code>代替<code>|</code>作为分隔符<br>符号|作为分隔符时有排版空间大小的问题，应该使用<code>\mid</code>代替，效果如下：<script type="math/tex; mode=display">\begin{array}{cc} \mathrm{Bad} & \mathrm{Better} \\ \hline \\ \{x | x^2 \in \Bbb Z\} & \{x \mid x^2 \in \Bbb Z \} \end{array}</script></li><li>多重积分<br>对于多重积分，不要使用<code>\int\int</code>此类的表达，应该使用<code>\iint \iiint</code>等特殊形式，效果如下：<script type="math/tex; mode=display">\begin{array}{cc} \mathrm{Bad} & \mathrm{Better} \\ \hline \\ \int\int_S f(x) \, dy \, dx & \iint_S f(x) \, dy \, dx \\ \int\int\int_V f(x) \, dz \, dy \, dx & \iiint_V f(x) \, dz \, dy \, dx \end{array}</script>此外，在微分前应该使用<code>\</code>,来增加些许空间，否则$\TeX$会将微分紧凑地排列在一起，如下：<script type="math/tex; mode=display">\begin{array}{cc} \mathrm{Bad} & \mathrm{Better} \\ \hline \\ \iiint_V f(x) dz dy dx & \iiint_V f(x) \, dz \, dy \, dx \end{array}</script></li><li>连分数<br>书写连分数表达式时，请使用<code>\cfrac</code>代替<code>\frac</code>或者<code>\over</code>，两者效果对比如下：<script type="math/tex; mode=display">x = a_0+\cfrac{1^2}{a_1+\cfrac{2^2}{a_2+\cfrac{3^2}{a_3+\cfrac{4^2}{a_4+\cdots}}}} \tag{\cfrac}</script><script type="math/tex; mode=display">x = a_0+\frac{1^2}{a_1+\frac{2^2}{a_2+\frac{3^2}{a_3+\frac{4^2}{a_4+\cdots}}}} \tag{\frac}</script></li><li>方程组<br>使用<code>\begin{array}...\end{array}</code>与<code>\left{...与\right.</code>配合表示方程组，如：<script type="math/tex; mode=display">\left\{ \begin{array}{c} a_1x+b_1y+c_1z=d_1 \\ a_2x+b_2y+c_2z=d_2 \\ a_3x+b_3y+c_3z=d3 \end{array} \right.</script>同时，还可以使用<code>\begin{cases}...\end{cases}</code>表达同样的方程组，如：<script type="math/tex; mode=display">\begin{cases} a_1x+b_1y+c_1z=d_1 \\ a_2x+b_2y+c_2z=d_2 \\ a_3x+b_3y+c_3z=d_3 \end{cases}</script>对齐方程组中的<code>=</code>号，可以使用<code>\begin{aligned}...\end{aligned}</code>，如：<script type="math/tex; mode=display">\left\{ \begin{aligned} a_1x+b_1y+c_1z & = d_1+e_1 \\ a_2x+b_2y & = d_2 \\ a_3x+b_3y+c_3z & = d_3 \end{aligned} \right.</script><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2>indicator function: <code>\mathbb{I}</code>$\mathbb{I}$<br>空心的符号：<code>\mathbb{KL}</code><br>向量、矩阵：<code>\mathrm{x, y}</code><br>实值：<code>x</code> $x$<br>使用 <code>\begin{align}</code> 时，在每个式子末尾加上 <code>\nonumber</code> 可以去掉显示式子的标号</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MathJax简介&quot;&gt;&lt;a href=&quot;#MathJax简介&quot; class=&quot;headerlink&quot; title=&quot;MathJax简介&quot;&gt;&lt;/a&gt;MathJax简介&lt;/h1&gt;&lt;p&gt;MathJax是一款运行在浏览器中的开源数学符号渲染引擎，使用MathJax可以方便的在浏览器中显示数学公式，不需要使用图片。目前，MathJax可以解析Latex、MathML和ASCIIMathML的标记语言。MathJax项目于2009年开始，发起人有American Mathematical Society, Design Science等，还有众多的支持者，个人感觉MathJax会成为今后数学符号渲染引擎中的主流，也许现在已经是了。本文接下来会讲述MathJax的基础用法，但不涉及MathJax的安装及配置。此外，推荐使用StackEdit学习MathJax的语法，它支持Markdown和MathJax。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="其他" scheme="https://nickwald.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="MathJax" scheme="https://nickwald.top/tags/MathJax/"/>
    
  </entry>
  
  <entry>
    <title>加密-私人空间</title>
    <link href="https://nickwald.top/2020/05/04/%E4%B8%AA%E4%BA%BA%E7%A9%BA%E9%97%B4/"/>
    <id>https://nickwald.top/2020/05/04/%E4%B8%AA%E4%BA%BA%E7%A9%BA%E9%97%B4/</id>
    <published>2020-05-04T04:52:58.737Z</published>
    <updated>2020-05-23T09:17:45.044Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="当前任务"><a href="#当前任务" class="headerlink" title="当前任务"></a>当前任务</h1>]]></content>
    
    <summary type="html">
    
      私人空间（羞羞脸）游客止步哈！~
    
    </summary>
    
    
      <category term="私人" scheme="https://nickwald.top/categories/%E7%A7%81%E4%BA%BA/"/>
    
    
      <category term="私人" scheme="https://nickwald.top/tags/%E7%A7%81%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>置顶-博客欢迎页</title>
    <link href="https://nickwald.top/2020/05/02/%E5%8D%9A%E5%AE%A2%E6%AC%A2%E8%BF%8E%E9%A1%B5/"/>
    <id>https://nickwald.top/2020/05/02/%E5%8D%9A%E5%AE%A2%E6%AC%A2%E8%BF%8E%E9%A1%B5/</id>
    <published>2020-05-02T10:02:15.168Z</published>
    <updated>2020-05-23T09:17:41.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎来到我的博客！"><a href="#欢迎来到我的博客！" class="headerlink" title="欢迎来到我的博客！"></a>欢迎来到我的<a href="https://nickwald.top">博客</a>！</h1><h1 id="Welcome-to-my-BLOG"><a href="#Welcome-to-my-BLOG" class="headerlink" title="Welcome to my BLOG!"></a>Welcome to my <a href="https://nickwald.top">BLOG</a>!</h1><a id="more"></a><h2 id="Q-这是做什么的？"><a href="#Q-这是做什么的？" class="headerlink" title="Q:这是做什么的？"></a>Q:这是做什么的？</h2><p>A: 这里可以算是一个杂物箱，里面有平时生活见闻的分享和思考，也有见到的好词佳句，美文，富有哲理的评论的摘录，或者是笔者平时对于时事热点的思考讨论，亦或技术性文章和报告……当然，希望这个杂物箱中能有任何东西帮助到您！</p><h2 id="Q-我能参与进讨论吗？"><a href="#Q-我能参与进讨论吗？" class="headerlink" title="Q: 我能参与进讨论吗？"></a>Q: 我能参与进讨论吗？</h2><p>A: 当然可以！非常欢迎您的评论！也希望您能斧正鄙人的疏漏之处或指教疑难不解之处，感激不尽！</p><h2 id="Q-博主的身份？"><a href="#Q-博主的身份？" class="headerlink" title="Q: 博主的身份？"></a>Q: 博主的身份？</h2><p>A: 关于博主的身份可以查看侧边栏的<strong>“关于”</strong>，在这里恕不再累述！</p><h2 id="Q-为什么有些文章提示需要密码？"><a href="#Q-为什么有些文章提示需要密码？" class="headerlink" title="Q: 为什么有些文章提示需要密码？"></a>Q: 为什么有些文章提示需要密码？</h2><p>A: 部分文章由于隐私或其它原因不便或不适合于公开于是对其进行了加密，访问者需要特定密码才可以访问哦！对您造成困扰和不便非常抱歉！</p>]]></content>
    
    <summary type="html">
    
      点击阅读全文可以进入文章哦！
    
    </summary>
    
    
      <category term="欢迎" scheme="https://nickwald.top/categories/%E6%AC%A2%E8%BF%8E/"/>
    
      <category term="其他" scheme="https://nickwald.top/categories/%E6%AC%A2%E8%BF%8E/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="欢迎" scheme="https://nickwald.top/tags/%E6%AC%A2%E8%BF%8E/"/>
    
  </entry>
  
</feed>
